Ideas and Selection Rationale
    Academic resource platform
    Features:
    - User accounts/profiles
    - Upload/download study materials
    - Calendar w assignment tracking
    Purpose:
    Help students to stay organized, share study materials and track assignments

Branching Strategy
    I will have a main branch, a feature branch where I add new features and a test branch where I actually develop new features and maek sure they work

Branch Usage Reflections

Django Setup
    The app name is meant to be just a placeholder but I am confused about what the startproject folder_name step was about
Virtual Environment Choices
    I don't understand what is meant by my choice of virtual environment
_______________________________________________________
Assignment 3:
Why these models/fields?:
The main content of the site will be study materials and a calendar with due dates, so I figured I'd need those and their relationship to the user.
Your relationship choices:
Materials and assignments need to be deleted in the event the user is deleted because they belong strictly to the user
Constraints:
Email is unique because no 2 users should be using the same email
How you seeded test data:
I added a few random examples of what materialsa user might have and made a couple of example assignments
--------------------------------------------------------
Assignment 4:
I wrote two views because the HttpResponse view returns raw HTML as a string whereas the render() view queries the model, passes it to a context dictionary,
and then returns a rendered template.
This means that the render()method will actually show the content of the model, but I'm honestly uncertain what the HttpResponse is meant to show.

Assignment 6:
Filtering:
- Leaves only data that fits a given criteria
- For example, searching for "John" returns the users whos email contains John
Aggregation:
- Show summaries of data
- For example, in my project I show total number of users
- I also show how many assignments are connected to each user

Assignment 5:
Base CBVs:
- You have to write the logic yourself inside get()
- You have to explicitly call objects.all()
- Doesn't know what to do with a model
Generic CBVs:
- More specialized
- Reduce boilerplate because it prevents you from doing things manually
Refactoring is useful because it improves readability and maintainability, reduces redundant queries, improves response times
and prevents you from having to repeat code. For urls it avoids having to have deeply nested URLs in favor of cleaner paths.

Assignment 7:
    - Static files are files that are stored and referenced for use in other pages
    - My chart shows total assignments per user
    - I used Count
    - BytesIO allows you to store a temporary object in memory rather than on a disk
    - tight_layout() adjust spacing between chart elements so that nothing gets cut off

Assignment 8:
    - CSRF is used to ensure only authorized users can use methods like POST to prevent unauthorized changes to the website
    - Key steps in Djangos form submission process:
        > Request comes in
        > If POST: create a Form object and bind it to the submitted data
        > Validate / clean the form / data
        > Render the form
    - FBV Pros
        > Simple and flexible
    - FBV Cons
        > Lack of built-in tools
        > You may have to rewrite common patterns many times
    - CBV Pros
        > Using generic views such as CreateView, UpdateView, and ListView avoids rewriting common patterns
    - CBV Cons
        > Can be harder to understand because of being less explicit
    - Use GET when:
        > Requesting data
        > Dealing with non-sensitive data
    - Use POST when:
        > Creating/updating data
        > Dealing with sensitive data

Assignment 9:
    - JSON API
        I think it's just an API that uses JSON for input and output
    - HttpResponse vs JsonResponse
        > I think HttpResponse returns raw html/text/images and JsonResponse returns more structured data
    - The chart shows the total number of assignments per user.
        > build absolute url to the api
        > pull json from the api using absolute url
        > save rows into lists
        > rows are turned into a PNG using matplotlib
        > PNG is returned using HttpResponse

Assignment 10:
    - I chose PokeAPI mostly because it seemed cool and I like Pokemon
    - I extracted the name, types, height and weight field because that's probably what would
        be included in a Pokedex entry
    - I returned an error jsonresponse if an exception occurs

Assignment 11:
Part 1:
    - I generated the csv file by opening a csv writer and then giving that csv writer a list of values from the User table that I wanted it to write into the file
    - I generated the json file by putting a list of the data from the User table into a dictionary that I then returns as a json response
    - I included the user id and email columns in the files
    - The reports page includes summaries of assignments per user and materials per user